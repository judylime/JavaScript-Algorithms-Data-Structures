<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p>
    General React â€“ React Interview Questions
    
    Â Differentiate between Real DOM and Virtual DOM.
    Â DOM akaÂ Document Object ModelÂ is an abstraction of structured code (HTML). Dom and HTML code are interrelated as the
    elements of HTML are known as nodes of DOM. It defines a structure where users modify the content present in the
    structure in any way they want (create, edit, alter, modify etc.). Basically, HTML is a text, DOM is an in-memory
    representation of this text.Â 
    The virtual DOM (VDOM)Â is an in-memory representation of Real DOM. The representation of a UI is kept in memory and
    synced åŒæ­¥ with the â€œrealâ€ DOM. Itâ€™s a step that happens between the render function being called and the displaying of
    elements on the screen. This entire process is called reconciliation.Â A virtual DOM is a lightweight JavaScript object
    which originally is just the copy of the real DOM.Â It is a node tree that lists the elements, their attributes and
    content as Objects and their properties.Â Reactâ€™s render function creates a node tree out of the React components. It
    then updates this tree in response to the mutations in the data model whichÂ is caused by various actions done by
    theÂ user or by the system.This Virtual DOM works in three simple steps.
    Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.
    Then the difference between the previous DOM representation and the new one is calculated.
    
    Once the calculations are done, the real DOM will be updated with only the things that have actually changed.Â 
    
    Real DOM vs Virtual DOM
    DOM Manipulation â€“Â Real DOM supports a very expensive DOM manipulation. Virtual DOM has an inexpensive DOM manipulation.
    Element Update â€“Â Real DOM creates a new DOM when an element updates. Virtual DOM doesnâ€™t do so in such a case. Instead,
    it updates the JSX.
    Memory Wastage â€“Â Real DOM causes a lot of memory wastage while there is no memory wastage for Virtual DOM.
    Update Speed â€“Â Real DOM updates slowly. On the other end, the virtual DOM updates faster.
    Updating HTML â€“Â Real DOM can directly update HTML, while virtual DOM canâ€™t update HTML directly.
    2. What is React?
    React is aÂ JavaScript-based UI library.Â It was developed at FacebookÂ with the purpose of creating interactive and
    reusable UI components.Â Â React is currently one of the most popular JavaScript framework used for handling the
    presentation layer for the web and mobile apps.
    3. What are the features of React?Â 
    Major features of React are listed below:
    It uses theÂ virtual DOMÂ instead of the real DOM.
    It usesÂ server-side rendering.
    It followsÂ uni-directional data flowÂ or data binding. å•å‘æ•°æ®æµ
    1ï¼‰React improves SEO performance React boost the performance of the SEO to higher levels as a search engine faces the
    problem while reading JavaScript of high loaded applications.
    2ï¼‰React acts as a standard for mobile app development
    3ï¼‰React makes the process of writing components easier Using React along with JSX will make you write components and
    code efficiently and clearly.
    4ï¼‰React increases efficiency As the React boostä¿ƒè¿› the efficiency of components by reusing them. This is the reason why
    it is considered as an ideal feature of React. It is considered as the most reusable system component.
    5ï¼‰ React ensures stable code It ensures the stability of the code of an application by making use of downward dataflow.
    
    4. List some of the major advantages of React.
    Excellent for developing complex and interactive web and mobile UI
    Follows the component-based approach and helps in building reusable UI components
    Features one of the largest community support
    Makes use of the virtual DOM instead of the real DOM
    Relies on server-side rendering
    Supports unidirectional data flow or data binding
    Usage of JSX makes easier to read and write code
    Improves the performance of applications with the use of virtual DOM
    Provides an easier way to integrate with frameworks
    It can be shared and rendered both on server and client-side
    Writing integration and unit tests can be made smother by using tools
    Q8: Does ReactJS use HTML? No, It uses JSX which is similar to HTML.
    5. What are the limitations of React?
    Limitations of React are listed below:
    React is just a library, not a full-blown framework
    Its library is very large and takes time to understand
    It can be little difficult for the novice æ–°æ‰‹programmers to understand
    Coding gets complex as it uses inline templating and JSX
    How React works?Ans.Â Below is the sequence of steps which gives an idea about how does react work
    Firstly the react runs the diffing algorithmç®—æ³• to identify the changes that are made in the virtual DOM.
    Next step is reconciliation, this is used to update the DOM as per the new features.
    Now, the virtual DOM, which is lightweight in nature and is detached from the specific implementation of the browser.
    Followingly the ReactElements which are present in virtual DOM are used to build basic nodes.
    Finally, if the ReactComponent changes the state; the diffing algorithm runs faster and identify the changes. After
    identification, it automatically updates the DOM with the change difference.
    
    6. What is JSX?
    JSX is a shorthand for JavaScript XML. This is a type of file used by React which utilizes the expressiveness of
    JavaScript along with HTML like template syntaxè¯­æ³•. This makes the HTML file really easy to understand. This file makes
    applications robust and boosts its performance. Below is an example of JSX:
    
    
    14. How Virtual-DOM is more efficient than Dirty checking?
    Â A:Â First thing to understand here is that in React, each component has a state which is observable. React knows when to
    re-render the sceneæƒ…æ™¯ because it is able to observe when this data changes. The observables are significantly faster
    than the Dirty checking because we donâ€™t have to poll æŠ•ç¥¨the data at a regular interval and check all of the values in
    the data structure recursivelyé€’å½’çš„. By comparison, setting a value on the state will signal to a listener that some state
    has changed. In a situation like that, React can simply listen for change events on the state and queue up
    re-rendering.Â Â Long story short, the virtual DOM is more efficient than the Dirty checking simply because it prevents
    all the unnecessary re-renders. Re-rendering only occurs when the state changes.
    8. Why canâ€™t browsers read JSX?
    Browsers can only read JavaScript objects but JSX in not a regular JavaScript object. Thus to enable a browser to read
    JSX, first, we need to transform JSX file into a JavaScript object using JSX transformers like Babel and then pass it to
    the browser.
    How many outermost elements can be there in a JSX expression?
    It must have one JSX element present so that the task can be accomplished easily. Having more than one expression is not
    an issue but probably it will slow down the process. There are also chances of confusion with more than one expression
    if you are new to this technology.
    
    
    9. How different is Reactâ€™s ES6 syntax when compared to ES5?:
    require vs import
    export vs exports
    props
    
    state
    10. How is React different from Angular?
    React vs Angular
    
    11. What do you understand from â€œIn React, everything is a component.â€
    Components are the building blocks of a React applicationâ€™s UI. These components split up the entire UI into small
    independent and reusable pieces. Then it renders each of these components independent of each other without affecting
    the rest of the UI.
    12. Explain the purpose ofÂ render()Â in React.
    Each React component must haveÂ aÂ render()Â mandatorilyå¿…é¡». It returns a single React element which is the representation
    of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together
    inside one enclosing tag such asÂ <form>, <group>,<div>Â etc. This function must be kept pure i.e., it must return the
          same result each time it is invoked.
          14. What is Props?
          Props is the shorthand for Properties in React. They are read-only components which must be kept pure i.e.
          immutable. They are always passed down from the parent to the child components throughout the application. A child
          component can never send a prop back to the parent component. This help in maintaining the unidirectional data
          flow and are generally used to render the dynamically generated data.
    
          13. How can you embed two or more components into one?
          We can embed components into one in the following way:
    
          15.Â What is a state in React and how is it used?
          States are the heart of React components. States are the source of data and must be kept as simple as possible.
          Basically, states are the objects which determine components rendering and behavior. They are mutable unlike the
          props and create dynamicåŠ¨æ€çš„ and interactive components. They are accessed viaÂ this.state()
          16. Differentiate between states and props.
          The state is a data structure that starts with a default value when a component mounts. It may be mutated
          æ”¹å˜çš„across time, mostly as a result of user events.Â Â Props, on the other hand, are a componentâ€™s
          configurationé…ç½®ã€æ„é€ . Think of them as the way for the components to communicate with each other. They are received
          from the above component and immutable as far as the component receiving them is concerned. A component isnâ€™t able
          to change its props, but it has to put together the props of its child components. While the props are mostly
          data, other things can be passed as them as well, for example, callback functions.Â Â Props and state do similar
          things but are used in different ways. The main difference is that props are immutableä¸å˜çš„ and cannot be changed
          while the state is used for mutable data or data that will change.
          States vs Props
    
          Changes inside child components are possible with props but not with state
          Changes inside the component arenâ€™t possible with props but with state
          Props allow for a parent component to change the value, state doesnâ€™t
          stateæ˜¯åˆšå¼€å§‹æ—¶é»˜è®¤çš„æ•°æ®ç»“æ„ï¼Œåœ¨ç»„ä»¶å†…è¢«æ”¹å˜ propsæ˜¯ç»„ä»¶çš„é…ç½®ï¼Œä¸å¯æ”¹å˜ï¼Œç”¨äºç»„ä»¶ä¹‹é—´çš„äº’é€š
          0. Is setState() async? Why?
          Â A:Â setState() actions are indeed asynchronous. setState() doesnâ€™t immediately mutate this.state. Instead, it
          creates a pending state transition. Accessing this.state after calling this method can potentially return the
          existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for
          performance gains.Â Â The reason behind is the way setState alters the state and causes rerendering. Making it
          synchronous might leave the browser unresponsive. That being said, the setState calls are asynchronous as well as
          batched for better UI experience and performance. Keep this in mind as this is definitely among the most popular
          50 interview questions and answers when it comes to React.
          17. How can you update the state of a component?
          State of a component can be updated using this.setState().
    
          18. What is arrow function in React? How is it used?
          Arrow functions are more of brief syntaxè¯­æ³• for writing the function expression. They are also calledÂ â€˜fat arrowâ€˜
          (=>) the functions. These functions allow to bind the context of the components properly since in ES6 auto binding
          is not available by default. Arrow functions are mostly useful while working with the higher order functions.
    
          19.Â Differentiate between stateful and stateless components.
          Stateful vs Stateless
    
          20.Â What are the different phases of React componentâ€™s lifecycle?
          There are three different phases of React componentâ€™s lifecycle:
          Initial Rendering Phase:Â This is the phase when the component is about to start its life journey and make its way
          to the DOM.
          Updating Phase:Â Once the component gets added to the DOM, it can potentially update and re-render only when a prop
          or state change occurs. That happens only in this phase.
          Unmounting Phase:Â This is the final phase of a componentâ€™s life cycle in whichÂ the component is destroyed and
          removed from the DOM.
    
          21. Explain the lifecycle methods of React components in detail.
          componentWillMount()Â â€“Â Executed just before rendering takes place both on the client as well as server-side.
          componentDidMount()Â â€“Â Executed on the client side only after the first render.
          componentWillReceiveProps()Â â€“ Invoked as soon as the props are received from the parent class and before another
          render is called.
          shouldComponentUpdate()Â â€“Â ReturnsÂ true or false value based on certain conditions. If you want your component to
          update, returnÂ trueÂ else returnÂ false. By default, it returns false.
          componentWillUpdate()Â â€“ Called just before rendering takes place in the DOM.
          componentDidUpdate()Â â€“Â Called immediately after rendering takes place.
          componentWillUnmount()Â â€“ Called after the component is unmounted from the DOM. It is used to clear up the memory
          spaces.
          22.Â What is an event in React?
          In React, events are the triggeredè§¦å‘çš„ reactions to specific actions like mouse hover, mouse click, key press,
          etc.Â Handling these events are similar to handling events in DOM elements. But there are some syntactical
          è¯­æ³•çš„differences like:
          Events are named using camel case instead of just using the lowercase.
          Events are passed as functions instead of strings.
          The event argumentå˜é‡ contains a set of properties, which are specific to an event. Each event type contains its
          own properties and behavior which can be accessed via its event handler only.
          23.Â How do you create an event in React?
    
          24.Â What are synthetic eventsåˆæˆäº‹ä»¶ in React?
          Synthetic events are the objects which act as a cross-browser wrapper around the browserâ€™s native event. They
          combine the behavior of different browsers into one API. This is done to make sure that the events show consistent
          properties across different browsers.
    
    
    
          25.Â What do you understand by refs in React?
          Refs is the short hand for References in React. It is an attribute which helps to store a reference to a
          particular React element or component, which will be returned by the components render configurationé…ç½® function.
          It is used to return references to a particular element or component returned by render(). They come in handy when
          we need DOM measurements or to add methods to the components.
          RefsÂ are an escape hatchå®‰å…¨èˆ±å£ which allow you to get direct access to a DOM element or an instance of a component.
          In order to use them you add a ref attribute to your component whose value is a callback function which will
          receive the underlying DOM element or the mounted instance of the component as its first argument.
          class UnControlledForm extends Component {
          handleSubmit = () => {
          console.log("Input Value: ", this.input.value) //å°†è·å–çš„inputçš„å€¼è¾“å…¥å®ä¾‹
          }
          render () {
          return (
          <form onSubmit={this.handleSubmit}>
            <input type='text' ref={(input)=> this.input = input} /> //ä»DOMä¸­è·å–inputçš„å€¼
            <button type='submit'>Submit</button>
          </form>
          )
          }}
          Above notice that our input field has a ref attribute whose value is a function. That function receives the actual
          DOM element of input which we then put on the instance in order to have access to it inside of the handleSubmit
          function.
          Itâ€™s often misconstrued that you need to use a class component in order to use refs, but refs can also be used
          with functional components by leveraging closures in JavaScript.
          26.Â List some of the cases when you should use Refs.
          Following are the cases when refs should be used:
          When you need to manage focus, select text or media playback
          To trigger imperative animationså¿…è¦çš„åŠ¨ç”»ã€‚
          Integrate with third-party DOM libraries
          æˆä¸ºä¸€ä½“
          What is the difference between aÂ controlledÂ component and anÂ uncontrolledÂ component?
          AÂ controlledÂ component is a component where React is inÂ controlÂ and is the single source of truth for the form
          data. As you can see below,Â usernameÂ doesnâ€™t live in the DOM but instead lives in our component state. Whenever we
          want to updateÂ username, we callÂ setStateÂ as weâ€™re used to.
          In HTML, form elements such asÂ <input>,Â <textarea>, andÂ <select>Â typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned å‰é¢æåŠçš„elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g.Â onChangeÂ is fired as the state will be updated. An input form element whose value is controlled by React in this way is called aÂ controlled component.
    class ControlledForm extends Component {
      state = {
        username: ''
      }
      updateUsername = (e) => {
        this.setState({
          username: e.target.value,
        })  }
      handleSubmit = () => {}
      render () {
        return (
          <form onSubmit={this.handleSubmit}>
            <input
              type='text'
              value={this.state.username}
              onChange={this.updateUsername} />
            <button type='submit'>Submit</button>
          </form>
        ) }}
    AnÂ uncontrolledÂ component is where your form data is handled by the DOM, instead of inside your React component.You useÂ refsÂ to accomplish this.
    class UnControlledForm extends Component {
      input = React.createRef()
      handleSubmit = () => {
        console.log("Input Value: ", this.input.current.value)
      }
      render () {
        return (
          <form onSubmit={this.handleSubmit}>
            <input
              type='text'
              ref={} />
            <button type='submit'>Submit</button>
          </form>
        ) }}
    There are components in the ReactJS that maintain their own internal state. They are basically considered as uncontrolled components. On the other side, the components which donâ€™t maintain any internal state are considered as controlled components.Though uncontrolled components are typically easier to implement since you just grab the value from the DOM using refs, itâ€™s typically recommended that you favor controlled components over uncontrolled components. The main reasons for this are that controlled components support instantå³æ—¶ field validation, allow you to conditionally disable/enable buttons, enforce input formats, and are more â€œthe React wayâ€. 
    
    
    
    22Whatâ€™s the difference between an Element and a Component in React?A:Â React element is an object representation of some UI. Basically, it describes what you want to see on the screen. A React component, on the other hand, is a function or a class that optionally accepts input and returns a React element. This is also one of the common interview questions on ReactJS.Â 
    21. Explain the difference between functional and class components.
    Â A:Â The components that return React elements as a result are called functional components. They are basically just simple JavaScript functions. They, however, havenâ€™t been around for longè¿˜æ²¡å‡ºç°å¾ˆä¹…. In fact, they have been introduced with React 0.14.Â Â Class components, on the other hand, have been around for quite some timeæœ‰ä¸€æ®µæ—¶é—´äº†. They use plain Java objects for creating pages. With the Reactâ€™s create-a-class-factory method, a literal is passed in defining the methods of a new component.
    32.Â What are Pure Components?
    PureÂ components are the simplest and fastest components which can be written. They can replace any component which onlyÂ hasÂ aÂ render().Â These components enhance the simplicity of the code and performance of the application.
    
    27.Â How do you modularize code in React?
    We can modularize code by using the export and import properties. They help in writing the components separately in different files.
    
    
    28. HowÂ are formsÂ created in React?
    React forms are similar to HTML forms. But in React, the state is contained in the state property of the component and is only updated via setState(). Thus the elements canâ€™t directly update their state and their submission isÂ handled by a JavaScript function. This function has full access to the data that is entered by the user into a form.
    
    30.Â What are Higher Order Components(HOC)?
    Higher Order Component is an advanced way of reusing the component logic. HOC in React are functions that take and return components. Basically,Â itâ€™s a pattern that is derived from Reactâ€™s compositional nature. HOC are custom components which wrap another component within it. They can accept any dynamicallyåŠ¨æ€åœ° provided child component but they wonâ€™t modify or copy any behavior from their input components. They are functions that loop over and apply functions to every element in an array. You can say that HOC are â€˜pureâ€™ components.
    31.Â What can you do with HOC?
    Code reuse, logicé€»è¾‘ and bootstrap abstraction å¼•å¯¼
    Render High jacking æ¸²æŸ“åŠ«æŒ
    State abstraction and manipulation çŠ¶æ€æŠ½è±¡å’Œæ“çºµ
    Props manipulation é“å…·æ“çºµ
    33.Â What is the significanceé‡è¦æ€§ of keys in React?
    Keys are used for identifying unique Virtual DOM Elements with their corresponding data driving the UI. They help React to optimizeä¼˜åŒ– the rendering by recycling all the existing elements in the DOM. These keys must be a unique number or string, using whichÂ React just reorders the elements instead of re-rendering them. This leads toÂ increase in applicationâ€™s performance.They allow React to reorder the elements instead of re-rendering them, which increases the appâ€™s performance.Â 
    React Redux â€“ React Interview Questions
    34.Â What were the major problems with MVC framework?
    DOM manipulation was very expensive
    Applications were slow and inefficient
    There was huge memory wastage
    Because of circular dependencies, a complicated model was created around models and views
    35.Â Explain Flux.
    Flux is an architectural pattern which enforces the uni-directional data flow. It controls derivedå¯¼å‡º data and enables communication between multiple components using a central Store which has authority for all data.Â Any update in data throughout the application must occur here only. Flux provides stability to the application and reduces run-time errors.
    
    This is another one of the common interview questions on React js. You should know that Flux is an application architecture for creating data layers in JavaScript apps. It is neither a framework nor a library, but a type of architecture that complementsè¡¥è¶³ the concept of Unidirectional Data Flow.
    Mention the key benefits of Flux?
    Applications that are built on Flux have components that can simply be tested. By simply updating the store, developers are able to manage and test any react component. It cut down the overall risk of data affection. All the applications are highly scalableå¯æ‰©å±•çš„ and suffer no compatibility issues.
    
    
    36.Â What is Redux?
    Redux is one of the hottest libraries for front-end development in todayâ€™s marketplace. It is a predictable state container for JavaScript applications and is used for the entire applications state management. Applications developed with Redux are easy to test and can run in different environments showing consistent behavior.
    The basic idea of Redux is that the entire application state is kept in a single store which is simply a JavaScript object. If you want to change the state, you need to fire actionsè§¦å‘æ“ä½œ from your application and then write reducers for these actions that modify the state. The entire state transition is kept inside reducers and isnâ€™t supposed to have any side effects.Â Â The general idea behind Redux is that there should be only a single source of truth for your application state, such as the UI state (which tab is active) or the data state (the user profile details).Â Â All of the data is retained in the Redux store. The createStore function is used to create mentioned stores. This function accepts another function as an argument. The passed in function (also known as the reducer) is responsible for returning the state of the application at a certain point in time which is then persisted in the store.
    1. Explain the components of Redux.
    Â A:Â This is another common Redux React question. You should know that Redux is composed of the following components:Â 
    ActionÂ â€” The action is the only source of information that sends data from our application to our store. Actions are sent the store using store.dispatch().
    ReducerÂ â€” Reducers specify how the appâ€™s state changes in response to actions sent to the store. Since the actions donâ€™t show the applicationâ€™s state changes, this place determines how the state will change to an action.
    StoreÂ â€” The Store is the object that brings Action and Reducer together. The store has the following responsibilities: Holds application state; Allows access to the state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener); Handles unregistering of listeners via the function returned by subscribeÂ (listener).
    Â That being said, keep in mind that there is only a single store in a Redux application. When we want to split the data handling logic, we need to use the reducer composition instead of many stores.
    9. What are the advantages of Redux?
    Predictability of outcome â€“Â With only one source of truth, i.e. the store, there is no confusion about how to sync the current state with actions and other parts of the application.
    MaintainabilityÂ â€“ The code becomes easier to maintain with a predictable outcome and strict structure.
    Server-side renderingÂ â€“ You just need to pass the store created on the server to the client side. Not only is this good for the initial render but it also provides a better user experience as it optimizes the app performance.
    Developer toolsÂ â€“ From actions to state changes, developers can track everything going on in the application in real time.
    Community and ecosystemÂ â€“ Anyone who has been new to something at some point in life (havenâ€™t we all?) knows the importance of a solid community and its support. Luckily, Redux has a huge community of talented individuals that constantly contribute to the betterment of the library and develop various apps with it.
    Ease of testingÂ â€“ Reduxâ€™s code is easily testable and independent, mostly because the functions are small, pure, and isolated.
    OrganizationÂ â€“ Redux is precise about how code should be organized which makes the code more consistent and easier when a team works on it.
    
    37.Â What are the three principles that Redux follows?
    Single source of truth:Â TheÂ stateÂ of the entire application is stored in an object/ state tree within a singleÂ store.Â The single state tree makes it easier to keep track of changes over time and debug or inspect the application.
    StateÂ is read-only:Â The only way to change the state is to trigger è§¦å‘anÂ action.Â An action is a plain JS object describing the change. Just like state is the minimal representation of data, the action is the minimal representation of the change to that data.Â 
    Changes are made with pure functions:Â In order to specify how the state tree is transformed by actions, you need pure functions. Pure functions areÂ those whose return value depends solely on the values of their arguments.
    
    38.Â What do you understand by â€œSingleÂ source of truthâ€?
    Redux uses â€˜Storeâ€™ for storing the applicationâ€™s entireÂ state at one place. So all the componentâ€™s state are stored in the Store and they receive updates from the Store itself. The single state tree makes it easier to keep track of changes over time and debug or inspect the application.
    39. List down the components of Redux.
    Redux is composed of the following components:
    ActionÂ â€“ Itâ€™s an object that describes what happened.
    ReducerÂ â€“ Â It is a place to determine how the state will change.
    StoreÂ â€“ State/ Object tree of the entire application is saved in the Store.
    ViewÂ â€“ Simply displays the data provided by the Store.
    40.Â Show how the data flows through Redux?
    
    
    
    
    41. How are Actions defined in Redux?
    Actions in React must have a type property that indicates the type of ACTION being performed. They must be defined as a String constant and you can add more properties to it as well. In Redux, actions are created using the functions called Action Creators. Below is an example of Action and Action Creator:
    
    What is Use of Redux thunkå½¢å®è½¬æ¢ç¨‹åº?
    Ans: Redux thunk acts as middleware which allows an individual to write action creators that return functions instead of actions. This is also used as a delay function in order to delay dispatch of an action if a certain condition is met. The two store methods getState() and dispatch() are provided as parameters to the inner function.
    
    
    42.Â Explain the role of Reducer.
    Reducers are pure functions which specify how the applicationâ€™s state changes in response to an ACTION. Reducers work by taking in the previous state and action, and then it returns a new state. It determines what sort of update needs to be done based on the type of the action, and then returns new values. It returns the previous state as it is,Â if no work needs to be done.
    What are pure functional Components?
    Traditional React Components as we have seen so far are making a class with class Example extends React.Component or React.createClass(). These make stateful components on the off chance that we at any point set the state (i.e. this.setState(), getInitialState(), or this.state = {} inside a constructor()).Â 
    In the event that we have no expectation for a Component to require state, or to require lifecycle methods, we can really compose Components with a pure function, consequently the expression "pure function Component":
    
    This function that returns a React Element can be used wherever we see fit:
    
    You might notice that also takes a prop â€“ we can still pass information into the Component.
    Â 
    What are the stateless components?
    On the off chanceæå°çš„æœºä¼š that React components are basically state machines that produce UI markupæ ‡è®°, at that point what are stateless segmentsæ®µï¼Œéƒ¨åˆ†?Â 
    Stateless components (a kind of "reusable" components) are simply pure functions that render DOM construct exclusively with respect to the properties gave to them.Â 
    As you can see, this component has no requirement for any internal state â€” not to mention a constructor or lifecycle handlers. The yield of the component is absolutely a function of the properties gave to it.
    43.Â What is the significanceé‡è¦æ€§ of Store in Redux?
    A store is a JavaScript object which can hold the applicationâ€™s state and provide a few helper methods to access the state, dispatch actions and register listeners. The entire state/ object tree of an application is saved in a single store. As a result of this, Redux is very simple and predictable. We can pass middleware to the store to handle the processing of data as well as to keep a log of various actions that change the state of stores.Â All the actions return a new state via reducers.
    44.Â How is Redux different from Flux?
    Description of Fluxï¼šIn the Flux pattern, the Store is the central authority for all data; any mutations to the data must occur within the store. Changes to the Store data are subsequentlyéšå broadcastä¼ æ’­ to subscribingè®¢é˜… Views via events. Views then update themselves based on the new state of received data. Â its core purpose is to control derived data so that multiple components can interact with that data without risking pollution.
    To request changes to any Store data, Actions may be firedè§¦åŠ¨. These Actions are controlled by a central Dispatcher; Actions may not occur simultaneouslyåŒæ—¶, ensuring that a Store only mutates data once per Action. The strict unidirectional flow of this Flux pattern enforces data stability, reducing data-related runtime errors throughout an application.
    
    Components â€“Â React components subscribe to the store in flux whereas in redux, container components utilize connect
    Dispatcher â€“Â There is no dispatcher in redux. On the other hand, flux has a singleton dispatcher
    Number of Stores â€“flux has several stores, only a single store for redux
    State â€“Â It is mutable for flux but immutable for redux
    Store â€“Â Influx, the store contains state as well as change logic. Contrary to this, the store in redux is separate from the change logic
    Store Type â€“Â All stores in flux are disconnected and flat. This is not the case with redux, where there is a single store with hierarchical reducers
    
    React Router â€“ React Interview Questions
    46.Â What is React Router?
    React Router is a powerful routing library built on top of React, which helps in adding new screens and flows to the application. This keeps the URL in sync with data thatâ€™s being displayed on the web page.Â It maintains a standardized structure and behavior and is used for developing single page web applications. React Router has a simple API.
    47.Â WhyÂ is switch keywordÂ used in React Router v4?
    Although aÂ <div>Â is used to encapsulateå‹ç¼© multiple routes inside the Router. The â€˜switchâ€™ keywordÂ is used when you want to display only a single route to be rendered amongst the several definedÂ routes.Â 
    TheÂ <switch>Â tag when in use matches the typed URL with the defined routes in sequentialé¡ºåºçš„ order.Â When the first match is found, it renders the specified route. Thereby bypassingç»•è¿‡ the remainingÂ routes.
    
    
    48. Why do we need a Router in React?
    A Router is used to define multiple routes and when a user types a specific URL, if this URL matches the path of any â€˜routeâ€™ defined inside the router, then the user is redirected to that particular route. So basically, we need to add a Router library to our app that allows creating multiple routes with each leading to us a unique view.
    
    49.Â List down the advantages of React Router.
    Just like how React is based on components, in React Router v4, the API isÂ â€˜All About Componentsâ€™. A Router can be visualized as a single root component (<BrowserRouter>) in which we enclose the specific child routes (<route>).
    No need to manually set History value: In React Router v4, all we need to do is wrap ourÂ routes within theÂ <BrowserRouter>Â component.
    The packages are split: Three packages one each for Web, Native and Core. This supports the compact size of our application. It is easy to switch over based on a similar coding style.
    
    Question:Â How does the React Router differ from conventional routing?
    Changes in the URL â€“Â A HTTP request is sent to a server for receiving a corresponding HTML page in conventional routing. React routing necessitates only for a change in the History attribute.
    Navigation â€“Â In conventional routing, the user actually navigates across different web pages for each individual view. In React routing, however, the users feel like they are navigating across distinct webpages while in actuality they arenâ€™t.
    Pages â€“Â Whereas in React routing only a single HTML page is involved, each view corresponds to a new file in conventional routing.
    
    What are React Hooks?Â What are React Hooks?
    HooksÂ are a new addition in React 16.8. They let you use state and other React features without writing a class. With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. Hooks allow you to reuse stateful logic without changing your component hierarchyå±‚æ¬¡ç»“æ„. This makes it easy to share Hooks among many components or with the community. 
    What are advantages of using React Hooks?Â What are advantages of using React Hooks?
    Primarily, hooks in general enable the extractionæå– and reuse of stateful logic that is common across multiple components without the burdenè´Ÿæ‹… of higher order components or render props. Hooks allow to easily manipulate the state of our functional component without needing to convert them into class components.
    Hooks donâ€™t work inside classes (because they let you use React without classes). By using them, we can totally avoid using lifecycle methods, such asÂ componentDidMount,Â componentDidUpdate,Â componentWillUnmount. Instead, we will use built-in hooks likeÂ useEffectÂ .
    What is useState() in React?Â 
    ...
    const [count, setCounter] = useState(0);
    const [moreStuff, setMoreStuff] = useState(...);
    ...
    
    const setCount = () => {
        setCounter(count + 1);
        setMoreStuff(...);
        ...
    };
    useStateÂ is one of build-in react hooks.Â useState(0)Â returns a tupleå…ƒç»„ï¼Œé‡æ•° where the first parameter count is the current state of the counter and setCounter is the method that will allow us to update the counter's state.
    We can use theÂ setCounterÂ method to update the state of count anywhere - In this case we are using it inside of the setCount function where we can do more things; the idea with hooks is that we are able to keep our code more functional and avoid class based components if not desired/needed.
    
    What is prop drillingé’»å­” and how can you avoid it?Â 
    When building a React application, there is often the need for a deeply nestedåµŒå¥—çš„ component to use data provided by another component that is much higher in the hierarchyå±‚æ¬¡. The simplest approach is to simply pass a prop from each component to the next in the hierarchy from the source component to the deeply nested component. This is calledÂ prop drilling.
    The primary disadvantage of prop drilling is that components that should not otherwise be aware of the data become unnecessarily complicated and are harder to maintain.
    To avoid prop drilling, a common approach is to use React context. This allows aÂ ProviderÂ component that supplies data to be defined, and allows nested components to consume context data via either aÂ ConsumerÂ component or aÂ useContextÂ hook.
    What happens during the lifecycle of a React component?
    High-Level Component Lifecycle
    At the highest level, React components have lifecycle events that fall into three general categories:
    Initialization
    State/Property Updates
    Destruction
    Every React component defines these events as a mechanismæœºæ¢°è£…ç½® for managing its properties, state, and rendered output. Some of these events only happen once, others happen more frequently; understanding these three general categories should help you clearly visualize when certain logic needs to be applied.For example, a component may need to add event listeners to the DOM when it first mounts. However, it should probably remove those event listeners when the component unmounts from the DOM so that irrelevant processing does not occur.
    class MyComponent extends React.Component {
      componentDidMount() { // when the component is added to the DOM...
        window.addEventListener('resize', this.onResizeHandler);
      }
      componentWillUnmount(){// when the component is removed from DOM...
        window.removeEventListener('resize', this.onResizeHandler);
      }
      onResizeHandler() {
        console.log('The window has been resized!');
      }}
    Low-Level Component Lifecycle
    
    Within these three general bucketsæ¡¶ exist a number of specific lifecycle hooks â€” essentiallyæœ¬è´¨ä¸Š abstractæŠ½è±¡çš„ methods â€” that can be utilized by any React component to more accurately manage updates. Understanding how and when these hooks fire is key to building stable components and will enable you to control the rendering process (improving performance).
    Take a look at the diagramå›¾è§£ above. The events under â€œInitializationâ€ only happen when a component is first initialized or added to the DOM. Similarly, the events under â€œDestructionâ€æ¯å only happen once (when the component is removed from the DOM). However, the events under â€œUpdateâ€ happen every time the properties or state of the component change.
    class MyComponent extends React.Component {
      // only re-render if the ID has changed!
      shouldComponentUpdate(nextProps, nextState) {
        return nextProps.id === this.props.id;
      }
    }
    Question #3: What can you tell me about JSX?
    When Facebook first released React to the world, they also introduced a new dialectæ–¹è¨€ of JavaScript called JSX that embedsä½¿åµŒå…¥ raw HTML templates inside JavaScript code. JSX code by itself cannot be read by the browser; it must be transpiled into traditional JavaScript using tools like Babel and webpack. While many developers understandably have initial knee-jerkä¸‹æ„è¯†çš„ reactions against it, JSX (in tandem with ES2015) has become the method of defining React components.
    class MyComponent extends React.Component {
      render() {
        let props = this.props;
        return (
          <div className="my-component">
            <a href={props.url}>{props.name}</a>
          </div>
        );
      }
    }
    This is certainly true. Having said that, many React developers prefer to use JSX as its syntaxè¯­æ³• is far more declarativeè¯´æ˜çš„ and reduces overall code complexity.
    import AnotherClass from './AnotherClass';
    class MyComponent extends React.Component {
      render() {
        let props = this.props;
        return (
          <div className="my-component">
            <AnotherClass {...props} />
          </div>
        );
      }
    Flux vs MVC
    Traditional MVC patterns have worked well for separating the concerns of data (Model), UI (View) and logic (Controller) â€” but many web developers have discovered limitations with that approach as applications grow in size. Specifically, MVC architectures frequently encounter two main problems:
    Poorly defined data flow:Â The cascadingä¸²è”ï¼Œå¤§é‡è½ä¸‹ updates which occur across views often lead to a tangledå¤æ‚çš„ web of events which is difficult to debug.
    Lack of data integrity:Â Model data can be mutated from anywhere, yielding unpredictable results across the UI.
    Question #5: What are stateless components?
    Stateless components (a flavor of â€œreusableâ€ components) are nothing more than pure functions that render DOM based solely on the properties provided to them.
    const StatelessCmp = props => {
      return (
        <div className="my-stateless-component">
          {props.name}: {props.birthday}
        </div>
      );};
    ReactDOM.render(
      <StatelessCmp name="Art" birthday="10/01/1980" />,
      document.getElementById('main'));
    This component has no need for any internal state â€” let alone a constructor or lifecycle handlers. The output of the component is purely a function of the properties provided to it.
    Bonus Question: Explain this Code
    class MyComponent extends React.Component {
      constructor(props) {
        // set the default internal state
        this.state = {
          clicks: 0
        };
      }
      componentDidMount() {
        this.refs.myComponentDiv.addEventListener('click', this.clickHandler);
      }
      componentWillUnmount() {
        this.refs.myComponentDiv.removeEventListener('click', this.clickHandler);
      }
      clickHandler() {
        this.setState({
          clicks: this.clicks + 1
        });
      }
      render() {
        let children = this.props.children;
    
        return (
          <div className="my-component" ref="myComponentDiv">
            <h2>My Component ({this.state.clicks} clicks})</h2>
            <h3>{this.props.headerText}</h3>
            {children}
          </div>
        );
      }
    }
    Given the code defined above, can you identify two problems?
    The constructor does not pass its props to the super class. It should include the following line:
    constructor(props) {
            super(props);
            // ...
        }
    The event listener (when assigned viaÂ addEventListener()) is not properly scoped becauseÂ ES2015 doesnâ€™t provide autobinding. Therefore the developer can re-assignÂ clickHandlerÂ in the constructor to include the correct binding to this:
    constructor(props) {
            super(props);
                  this.clickHandler = this.clickHandler.bind(this);
            // ...
        }
    Can you explain what the output of this class actually does? How would you use it in an application?
    This class creates aÂ <div />Â element and attaches a click listener to it. The content of this component includes aÂ <h2 />Â element that updates every time the user clicks on the parentÂ <div />, as well as anÂ <h3 />Â element containing a provided title and whatever child elements were passed to it. To use this class, the candidate should import it into another class and use it like this:
    <MyComponent headerText="A list of paragraph tags">
        <p>First child.</p>
        <p>Any other <span>number</span> of children...</p>
    </MyComponent>
    5. What is the difference between createElement and cloneElement?
    Basically, createElement what React uses to create React Elements, cloneElement, on the other hand, is used to clone an element and pass it new props.
    createElementÂ is what JSX gets compiled to and is what React uses to create React Elements (object representations of some UI).Â cloneElementÂ is used to clone an element and pass it new props. They nailed the naming on these two ğŸ™‚.
    
    
    
    
    What is equivalent of the following using React.createElement?Â 
    const element = (
      <h1 className="greeting">
        Hello, world!
      </h1>
    );
    Answer:
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Hello, world!'
    );
    Why should not we update the state directly?Â Why should not we update the state directly?
    If you try to update state directly then it wonâ€™t re-render the component.
        //Wrong   This.state.message =â€Hello worldâ€;
    Instead useÂ setState()Â method. It schedules an update to a componentâ€™s state object. When state changes, the component responds by re-rendering
        //Correct    This.setState({message: â€˜Hello Worldâ€™});
    34. What are syntheticç»¼åˆçš„ events in React?
    Â A:Â When talking about React js interview questions and answers, we should mention the synthetic events. They act as a cross-browser wrapper around the browserâ€™s native event thus combining the behavior of different browsers into one API. Their purpose is to ensure that the events show consistent properties across different browsers.Â 
    Question:Â How would you create a form in React?
    React forms are identical to HTML forms. However, the state is contained in the state property of the component in React and is updateable only via the setState() method.
    Therefore, the elements in a React form canâ€™t directly update their state. Their submission is handled by a JS function, which has full access to the data entered into the form by a user.
    handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
    }
    render() {
    return (
    );
    }
    Question:Â Where would you put AJAX calls in your React code?
    Answer:Â It is possible to use any AJAX library with React, such as Axios, jQuery AJAX, as well as the inbuilt browser window.fetch.
    Data with AJAX calls need to be added to the componentDidMount() lifecycle method. By doing this, it is possible to use the setState() method for updating component as soon as the data is retrieved.
    Question: Can browsers read JSX?
    Answer:Â No, the browsers cannot read JSX because it is not a regular JavaScript object.
    Question: Can we modularize code in React? How?
    Answer:Â Yes, we can modularize code in React. It can be done by using export and import properties.
    Whatâ€™s the difference between an Element and a Component in React?
    Simply put, a React element describes what you want to see on the screen. Not so simply put, a React element is an object representation of some UI.
    A React component is a function or a class which optionally accepts input and returns a React element (typically via JSX which gets compiled to a createElement invocation).
    In which lifecycle method do you make AJAX requests with a Class component?
    AJAX requests should go in theÂ componentDidMountÂ lifecycle method.
    The reason for this is because you canâ€™t guarantee the AJAX request wonâ€™t resolve before the component mounts. If it did, that would mean that youâ€™d be trying to setState on an unmounted component, which not only wonâ€™t work but React will yell at you for. Doing AJAX in componentDidMount will guarantee that thereâ€™s a component to update.
    In ReactJS, why there is a need to capitalize on the components?
    It is necessary because components are not the DOM element but they are constructorsæ„é€ å‡½æ•°. If they are not capitalized, they can cause various issues and can confuse developers with several elements. At the same time, the problem of integration of some elements and commands can be there.
  </p>
</body>
</html>